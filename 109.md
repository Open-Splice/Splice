# In this model, Grammar cuts thought complexity

It eliminates hidden control flow and incidental state coupling.

Literally, grammar cuts code into two sides:

* **A side** - file (110.c).
* **B side** - choice-machine side (my side).

A and B sides will interact with each other when we splice them together by running
the c-machine with the starting symbol of our grammar.

Then the c-machine will call axiomatic blocks defined by the grammar, according to grammar rules.

> Grammar dictates execution control flow; the c-machine obeys.

So when we receive execution control flow in one of the axiomatic blocks / Steps defined in 110.c,
we have everything.
We know exactly where we are in the parsing process, just like in recursive
descent you are doing, but now we know the same information without doing parsing.

It is done by the c-machine with executable grammar units, so we can do whatever we want:
build an AST, or directly interpret the language. Who needs an AST when we have a more powerful structure, grammar.

In essence, the incidental state coupling and complexity that we have in recursive descent get sucked
into the B-side, and executable grammar rules are visible and modifiable units.

We can even pause grammar execution by saving / pushing execution context.

All of this is possible by having a cyclic dependency between aStep and bStep with the choice machine (cm).

All Steps, both sides, including grammar rule units, share the following execution context:

```c
#define N(argo) void argo(int* o, int b, int a, int t, int s, int d)
#define S(argo) static N(argo)
```

Step is just a function with fixed parameters/context.
They are tail-call optimized, i.e. they are pure continuations and
do not use the call stack or do invisible side effects.

Interaction is possible by calling continuation Steps.
When the c-machine forwards control flow to an axiomatic block in 110.c, it
defines continuations we need to call at some point. Remember: we can pause, hence “at some point”.

```c
enum color_names { Red, Yellow, Green };
S(Red   ) { t = o[d + Red + 0],    d = o[t + 4 + 0], (o[t + 5 + 0] + cm)(o, b, a, t, s, d); }
S(Green ) { t = o[d + Green + 0],  d = o[t + 4 + 0], (o[t + 5 + 0] + cm)(o, b, a, t, s, d); }
S(Yellow) { t = o[d + Yellow + 0], d = o[t + 4 + 0], (o[t + 5 + 0] + cm)(o, b, a, t, s, d); }
```

* `Red` - do not continue parsing the current grammar rule; i.e. treat this position in the grammar rule as the end.
  This is useful to stop left-recursive growth. It is necessary to deal with the `dangling else` problem.
  See how the `if` statement is defined in 110.c as a left-recursive rule with `Red` continuation.
* `Green` - continue parsing.
* `Yellow` - go back in time (backtrack) and try the next choice.

